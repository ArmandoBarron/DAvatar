from flask import Blueprint, request, jsonify
from flask_api import status
import os
import json
import timeit
import pandas as pd
from datetime import datetime
from graphviz import Digraph

from .time_measurement import write_to_timelog
from .files import make_subfolders, write_jsons_to_disk
from .wot_td import make_wot_td_card
from .index_handler import get_solution_info_from_index, index_td_cards
from .datetime_handler import parse_RFC3339_datetime_to_str
from .constants import OUT_FOLDER, FLAG_SAVE_DATASETS

rep_bp = Blueprint("representation", __name__)


@rep_bp.route('/model/wot-td/<string:status_name>', methods=['POST'])
def make_solution_wottd_with_status(status_name):
  """Make the wot cards of a solution based on status previously generated by diagnosis.

  Args:
    status_name (str): the name that identify the status the solution,
    this name must be present in indexing

  Raises:
    ValueError: [description]

  Returns:
    [type]: [description]
  """
  if request.method != 'POST':
    return jsonify({'msg': 'use post'}), status.HTTP_405_METHOD_NOT_ALLOWED
  
  req = request.json
  if not req or not req.get('data_status'):
    return jsonify({'msg': 'no status data'}), status.HTTP_400_BAD_REQUEST
    
  starttime = timeit.default_timer()
  st = status.HTTP_500_INTERNAL_SERVER_ERROR
  payload = None
  sol_id = req.get('sol_id')
  sol_name = req.get('sol_name')
  exp = req.get('exp')
  dt_ini = req.get('dt_ini')
  dt_end = req.get('dt_end')
  ct = req.get('creation_time')
  cvs_status = req.get('data_status')

  # get raw solution information from index
  solution = get_solution_info_from_index(sol_id)

  # get model information into yml
  containers = None
  services = None
  x_model = None
  if solution and solution.get('data'):
    d = solution.get('data')
    containers = d.get('containers')
    if d.get('full_yml'):
      services = d.get('full_yml').get('services')
      x_model = d.get('full_yml').get('x-model-solution')

  if containers and services:

    all_tds = None
    nodes = None
    edges = None

    # dict means there is only one block of information
    if type(cvs_status) is dict:
      all_tds = process_status_solution(cvs_status, containers, x_model)

    # otherwise list means that there are chunks
    elif type(cvs_status) is list:
      # TODO: test and finish
      all_tds = []
      for chunk in cvs_status:
        cards = process_status_solution(chunk, containers, x_model)
        all_tds.append(cards)

    # create sink folder and save jsons to text file
    path = os.sep.join([os.getcwd(), OUT_FOLDER])
    make_subfolders(path)
    
    if x_model:
      nodes, edges = prepare_nodes_edges(services, containers, x_model.get('structure'))
    else:
      nodes, edges = prepare_nodes_edges(services, containers)
    draw_graph(nodes, edges, sol_name, 'dot', exportto='pdf')

    # save to index
    payload = {
      'sol_id': sol_id,
      'sol_name': sol_name,
      'exp': exp,
      'dt_ini': dt_ini,
      'dt_end': dt_end,
      'creation_time': parse_RFC3339_datetime_to_str(datetime.today()),
      'cards': all_tds,
      'structure': [nodes, edges]
    }
    index_td_cards(payload)
    
    path_file = os.sep.join([path, status_name+'_'+ct+'.txt'])
    write_jsons_to_disk(all_tds, path_file)
    
    msg = {'msg': 'Cards created', 'data': payload}
    st = status.HTTP_201_CREATED
  else:
    msg = {'msg': 'No containers'}
    st = status.HTTP_400_BAD_REQUEST
 
  takentime = timeit.default_timer() - starttime
  write_to_timelog('rep', takentime)
  return jsonify(msg), st

@rep_bp.route('/model/structure/<string:solution>', methods=['GET'])
def model_structure(solution):
  s_data = get_solution_info_from_index(solution)
  containers = None
  services = None
  x_model = None
  if s_data and s_data.get('data'):
    d = s_data.get('data')
    containers = d.get('containers')
    if d.get('full_yml'):
      services = d.get('full_yml').get('services')
      x_model = d.get('full_yml').get('x-model-solution')

  if containers and services:
    if x_model:
      nodes, edges = prepare_nodes_edges(services, containers, x_model.get('structure'))
    else:
      nodes, edges = prepare_nodes_edges(services, containers)
    data = {'nodes': nodes, 'edges': edges}
    return jsonify({'msj': 'Structure found', 'data': data}), status.HTTP_200_OK
  
  return jsonify({'msj': 'Not found'}), status.HTTP_404_NOT_FOUND

def process_status_solution(status_info, containers, x_model):
  cards = []
  df_ds = pd.read_json(json.dumps(status_info), orient='split')
  df_ds = df_ds.reset_index()
    
  # make a card by each cv
  unique_cvs = df_ds['index'].unique()
  for cv in unique_cvs:
    df_con = df_ds[df_ds['index'] == cv]
    d_mdn = df_con.iloc[3][1:-1]
    d_std = df_con.iloc[4][1:-1]
    d_thr = df_con.iloc[5][1:-1]

    u1 = d_mdn['cpu_util']
    u2 = d_mdn['filesystem_util']
    u3 = d_mdn['memory_util']
    u4 = d_mdn['network_util']

    # find model information of current container
    if x_model:
      m_info = get_model_info(cv, containers, x_model.get('x-services'))
    else:
      m_info = get_model_info(cv, containers)
      print('No container model information')
    card = make_wot_td_card(cv, m_info, u1, u2, u3, u4)
    cards.append(card)
  return cards

def get_model_info(cv_name, containers, x_model=None):
  cv_model_info = {}
  for k, v in containers.items():
    if v and v.get('name') and cv_name in v.get('name'):
        if x_model:
          cv_model_info = x_model.get(k)
        cv_model_info['id'] = v.get('id')
        break
  return cv_model_info

def prepare_nodes_edges(services, containers, structure=None):
  nodes = []
  edges = []

  for service, s_data in services.items():
    cv_name = containers.get(service).get('name')
    if cv_name:
      nodes.append([service, cv_name])
    else:
      nodes.append(service)
    links = s_data.get('links')
    depends = s_data.get('depends_on')
    if links:
      for l in links:
        edges.append([l, service])
    if depends:
      for d in depends:
        edges.append([d, service])
    
  if structure:
    for pair in structure:
      edges.append(pair.split('->'))

  return nodes, edges

def draw_graph(nodes, edges, filename, engine, exportto=None):
  modelname = OUT_FOLDER + '/' + filename + '.gv'
  rtn = 0
  if nodes and edges and FLAG_SAVE_DATASETS:
    try:
      # ENGINES: dot, neato, twopi, circo, fdp
      dot = Digraph(engine=engine)
      for n in nodes:
        if type(n) is list and len(n) >= 2:
          dot.node(n[0], n[1])
        else:
          dot.node(n)
      for e in edges:
        dot.edge(e[0], e[1])
      if exportto and exportto in ['svg', 'pdf']:
        dot.format = exportto
        dot.render(modelname, view=False)
      rtn = 1
      print(f'File saved: {modelname}')
    except:
      rtn = -1
  return rtn, modelname

